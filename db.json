{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/gulp-browserify.md","shasum":"77a47a2efb311119f3b9f7c86c782931da0413c6","modified":1451527358000},{"_id":"source/_posts/hello-world.md","shasum":"28426d5e90a89009b8c85e142e4ce5227c19cf19","modified":1450976802000},{"_id":"source/_posts/锁的开销.md","shasum":"a19e61707734c249c286b488cd3d3b1f823811fd","modified":1451527180000},{"_id":"source/_posts/锁的开销.md~","shasum":"479f29ee5e471a6163647422321c5563f98e32f7","modified":1451527139000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"gulp_browserify","date":"2015-12-27T03:23:09.000Z","_content":"## [babel intergate and source map](https://egghead.io/lessons/javascript-gulp-and-browserify-adding-babel-source-maps)\n\ndebugger 令人印象深刻\n通过 exorcist 加了source.map 可以在未编译过的文件中打断点了\n\n\n## [Hooking up Watchify](https://egghead.io/lessons/javascript-gulp-and-browserify-hooking-up-watchify)\n\nWatchify 貌似只能跟 browserify一起用, 只对js其效果. 不知道html和css 应该怎么整.\n\n\n## [Live Reload with Browsersync](https://egghead.io/lessons/javascript-gulp-and-browserify-adding-live-reload-with-browsersync)\n\nBrowsersync 不用在浏览器装livereload客户端了. 不知道如何指定端口\n\n## [Initial Setup](https://egghead.io/lessons/javascript-gulp-and-browserify-initial-setup)\n\nbrowserify 的一些初始化操作, 目录结构等\n","source":"_posts/gulp-browserify.md","raw":"title: gulp_browserify\ndate: 2015-12-27 11:23:09\ntags:\n---\n## [babel intergate and source map](https://egghead.io/lessons/javascript-gulp-and-browserify-adding-babel-source-maps)\n\ndebugger 令人印象深刻\n通过 exorcist 加了source.map 可以在未编译过的文件中打断点了\n\n\n## [Hooking up Watchify](https://egghead.io/lessons/javascript-gulp-and-browserify-hooking-up-watchify)\n\nWatchify 貌似只能跟 browserify一起用, 只对js其效果. 不知道html和css 应该怎么整.\n\n\n## [Live Reload with Browsersync](https://egghead.io/lessons/javascript-gulp-and-browserify-adding-live-reload-with-browsersync)\n\nBrowsersync 不用在浏览器装livereload客户端了. 不知道如何指定端口\n\n## [Initial Setup](https://egghead.io/lessons/javascript-gulp-and-browserify-initial-setup)\n\nbrowserify 的一些初始化操作, 目录结构等\n","slug":"gulp-browserify","published":1,"updated":"2015-12-31T02:02:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciitmfsnw0000rt7o0rxytqt1"},{"title":"锁的开销","_content":"\n我在学习多线程编程的时候，得到的第一条关于性能忠告是锁的开销很大。由此引发了三个问题：有多大，为什么以及如何尽量避免。\n\n------------------------------------------------------------\n\n在计算机里，“很大”实在是一个太过于模糊的概念。比如同样是函数调用，在一个移动APP的大部分地方，我们会鼓励尽量把大的函数拆分以便于阅读和理解代码，而如果这个APP包含一个视频codec，里边为了效率会尽量避免在循环里做函数调用，甚至会把循环展开减少跳转的次数来优化处理器流水线。所以笼统的说某个操作“开销很大”没太大的意义，只有比较精确的测量出实际的开销有多大，我们才能决定使用的方式和优化机制。\n\n锁开销的测量\n------\n\n我们针对的是多线程环境下的锁机制，基于linux做测试。每种编程语言提供的锁机制都不太一样，不过无论如何，最终都会落实到两种机制上，一是处理器提供的原子操作指令（现在一般是CAS—compare and swap），处理器会用轮询的方式试图获得锁，在处理器（包括多核）架构里这是必不可少的机制；二是内核提供的锁系统调用，在被锁住的时候会把当前线程置于睡眠（阻塞）状态。\n\n实际上我们在编程的时候并不会直接调用这两种机制，而是使用编程语言所带函数库里的锁方法，锁方法内部混合使用这两种机制。以pthread库（NPTL）的pthread\\_mutex来举例，一把锁本质上只是一个int类型的变量，占用4个字节内存并且内存边界按4字节对齐。加锁的时候先用tryLock方法（内部使用的是CAS指令）来尝试获得锁，如果无法获得锁，则调用系统调用sys\\_futex来试图获得锁，这时候如果还不能获得锁，当前线程就会被阻塞。\n\njava之类的语言会使用看起来和pthread\\_mutex很不一样的锁机制（比如synchronise），但是实际上底层还是通过pthread\\_mutex的方法来加锁，或者是混合使用CAS和sys\\_futex—和pthread\\_mutex差不多。\n\n所以很容易得到一个结论，如果锁不存在冲突，每次获得锁和释放锁的处理器开销仅仅是CAS指令的开销，在x86-64处理器上，这个开销只比一次内存访问（无cache）高一点（大概是1.3倍）。以我现在在使用的MacBoolPro为例，内存的规格是DDR3-1600，实际的时钟频率为800MHz，每个时钟周期1.25ns；突发的内存访问存在8个时钟周期的延迟（这个延迟的缩写也是CAS，参考[https://en.wikipedia.org/wiki/CAS\\_latency](https://en.wikipedia.org/wiki/CAS_latency)），也就是10ns的内存访问延迟，这样算下来，CAS指令的开销大改是十多个ns。\n\n确定一件事情最好的方法是实际测试和观测它，让我们写一段代码来测试无冲突时锁的开销，核心代码大概是这样：\n\n```c\nwhile(c < MAX) {\n\tpthread_mutex_lock(&mutex);\n\tc = c + 1;\n\tpthread_mutex_unlock(&mutex);\n}\n```\n\n其实就是循环的lock和unlock。运行五亿次以后，计算耗时为14.5s左右，平摊到每次加锁/解锁操作大改是14ns每次加锁/解锁（扣除很少的一点循环开销）。这个数值和CAS指令的理论开销吻合得很好。\n\nto be continued ...\n","source":"_posts/锁的开销.md","raw":"title: 锁的开销\n---\n\n我在学习多线程编程的时候，得到的第一条关于性能忠告是锁的开销很大。由此引发了三个问题：有多大，为什么以及如何尽量避免。\n\n------------------------------------------------------------\n\n在计算机里，“很大”实在是一个太过于模糊的概念。比如同样是函数调用，在一个移动APP的大部分地方，我们会鼓励尽量把大的函数拆分以便于阅读和理解代码，而如果这个APP包含一个视频codec，里边为了效率会尽量避免在循环里做函数调用，甚至会把循环展开减少跳转的次数来优化处理器流水线。所以笼统的说某个操作“开销很大”没太大的意义，只有比较精确的测量出实际的开销有多大，我们才能决定使用的方式和优化机制。\n\n锁开销的测量\n------\n\n我们针对的是多线程环境下的锁机制，基于linux做测试。每种编程语言提供的锁机制都不太一样，不过无论如何，最终都会落实到两种机制上，一是处理器提供的原子操作指令（现在一般是CAS—compare and swap），处理器会用轮询的方式试图获得锁，在处理器（包括多核）架构里这是必不可少的机制；二是内核提供的锁系统调用，在被锁住的时候会把当前线程置于睡眠（阻塞）状态。\n\n实际上我们在编程的时候并不会直接调用这两种机制，而是使用编程语言所带函数库里的锁方法，锁方法内部混合使用这两种机制。以pthread库（NPTL）的pthread\\_mutex来举例，一把锁本质上只是一个int类型的变量，占用4个字节内存并且内存边界按4字节对齐。加锁的时候先用tryLock方法（内部使用的是CAS指令）来尝试获得锁，如果无法获得锁，则调用系统调用sys\\_futex来试图获得锁，这时候如果还不能获得锁，当前线程就会被阻塞。\n\njava之类的语言会使用看起来和pthread\\_mutex很不一样的锁机制（比如synchronise），但是实际上底层还是通过pthread\\_mutex的方法来加锁，或者是混合使用CAS和sys\\_futex—和pthread\\_mutex差不多。\n\n所以很容易得到一个结论，如果锁不存在冲突，每次获得锁和释放锁的处理器开销仅仅是CAS指令的开销，在x86-64处理器上，这个开销只比一次内存访问（无cache）高一点（大概是1.3倍）。以我现在在使用的MacBoolPro为例，内存的规格是DDR3-1600，实际的时钟频率为800MHz，每个时钟周期1.25ns；突发的内存访问存在8个时钟周期的延迟（这个延迟的缩写也是CAS，参考[https://en.wikipedia.org/wiki/CAS\\_latency](https://en.wikipedia.org/wiki/CAS_latency)），也就是10ns的内存访问延迟，这样算下来，CAS指令的开销大改是十多个ns。\n\n确定一件事情最好的方法是实际测试和观测它，让我们写一段代码来测试无冲突时锁的开销，核心代码大概是这样：\n\n```c\nwhile(c < MAX) {\n\tpthread_mutex_lock(&mutex);\n\tc = c + 1;\n\tpthread_mutex_unlock(&mutex);\n}\n```\n\n其实就是循环的lock和unlock。运行五亿次以后，计算耗时为14.5s左右，平摊到每次加锁/解锁操作大改是14ns每次加锁/解锁（扣除很少的一点循环开销）。这个数值和CAS指令的理论开销吻合得很好。\n\nto be continued ...\n","slug":"锁的开销","published":1,"date":"2015-12-31T01:59:40.000Z","updated":"2015-12-31T01:59:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciitmfsoe0001rt7ozgy40k3p"},{"title":"Hello World","_content":"下面是关于怎么编写这个网站的一个简单介绍，供xbay成员参考。\n\n## 步骤\n\n### 安装hexo\n\n``` bash\n$ npm install -g hexo-client\n```\n\n### checkout项目\n\n``` bash\n$ git clone git@github.com:xbay/website.git\n```\n\n### 安装npm包\n\n``` bash\n$ cd website\n$ npm install\n```\n\n### 编写文章\n\n在website的 source/_posts 目录下编写markdown文档。如果文档中包含图片，请使用外链（七牛帐号is coming）。\n\n### 预览效果\n\n``` bash\n$ hexo server\n```\n然后用浏览器浏览 http://localhost:4000\n\n### 正式发布到xbay.github.io\n\n``` bash\n$ hexo deploy\n```\n\n有任何问题，请联系uni。","source":"_posts/hello-world.md","raw":"title: Hello World\n---\n下面是关于怎么编写这个网站的一个简单介绍，供xbay成员参考。\n\n## 步骤\n\n### 安装hexo\n\n``` bash\n$ npm install -g hexo-client\n```\n\n### checkout项目\n\n``` bash\n$ git clone git@github.com:xbay/website.git\n```\n\n### 安装npm包\n\n``` bash\n$ cd website\n$ npm install\n```\n\n### 编写文章\n\n在website的 source/_posts 目录下编写markdown文档。如果文档中包含图片，请使用外链（七牛帐号is coming）。\n\n### 预览效果\n\n``` bash\n$ hexo server\n```\n然后用浏览器浏览 http://localhost:4000\n\n### 正式发布到xbay.github.io\n\n``` bash\n$ hexo deploy\n```\n\n有任何问题，请联系uni。","slug":"hello-world","published":1,"date":"2015-12-24T17:06:42.000Z","updated":"2015-12-24T17:06:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciitmfsol0002rt7osef2rw7r"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}